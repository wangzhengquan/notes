<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://wangzhengquan.github.io/notes/graphics/opengl/Data%20shared%20between%20CPU%20and%20GPU/ rel=canonical><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.3.1, mkdocs-material-8.3.9"><title>Data shared between CPU and GPU - 笔记</title><link rel=stylesheet href=../../../assets/stylesheets/main.1d29e8d0.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.cbb835fc.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme data-md-color-primary=none data-md-color-accent=none> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#shaders class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=笔记 class="md-header__button md-logo" aria-label=笔记 data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> 笔记 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Data shared between CPU and GPU </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=笔记 class="md-nav__button md-logo" aria-label=笔记 data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> 笔记 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> 简介 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> OS (xv6) <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="OS (xv6)" data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> OS (xv6) </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../xv6/ class=md-nav__link> xv6简介 </a> </li> <li class=md-nav__item> <a href=../../../xv6/boot_loader/ class=md-nav__link> Boot loader </a> </li> <li class=md-nav__item> <a href=../../../xv6/entry_%20kernel/ class=md-nav__link> Entry kernel </a> </li> <li class=md-nav__item> <a href=../../../xv6/scheduler/ class=md-nav__link> Scheduler </a> </li> <li class=md-nav__item> <a href=../../../xv6/the_first_process/ class=md-nav__link> 第一个进程 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_6 type=checkbox id=__nav_2_6> <label class=md-nav__link for=__nav_2_6> 中断 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=中断 data-md-level=2> <label class=md-nav__title for=__nav_2_6> <span class="md-nav__icon md-icon"></span> 中断 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../xv6/interrups_process/ class=md-nav__link> 中断处理流程 </a> </li> <li class=md-nav__item> <a href=../../../xv6/system_call/ class=md-nav__link> 系统调用 </a> </li> <li class=md-nav__item> <a href=../../../xv6/timer_interrupt/ class=md-nav__link> 时间中断 </a> </li> <li class=md-nav__item> <a href=../../../xv6/disk_interrupt/ class=md-nav__link> 硬盘中断 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../../xv6/file_system/ class=md-nav__link> 文件系统 </a> </li> <li class=md-nav__item> <a href=../../../xv6/device/ class=md-nav__link> 设备管理 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Math <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Math data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Math </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../math/Rodrigues%27%20rotation/Rodrigues%27%20rotation/ class=md-nav__link> Rodrigues' rotation </a> </li> <li class=md-nav__item> <a href=../../../math/Quaternions/Quaternions/ class=md-nav__link> Quaternions </a> </li> <li class=md-nav__item> <a href=../../../math/Windowing%20transformations/ class=md-nav__link> Windowing transformations </a> </li> <li class=md-nav__item> <a href=../../../math/distance%20from%20point%20to%20plane/ class=md-nav__link> distance from point to plane </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4> graphics <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=graphics data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> graphics </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Data shared between CPU and GPU <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Data shared between CPU and GPU </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#shaders class=md-nav__link> Shaders </a> </li> <li class=md-nav__item> <a href=#per-vertex-data class=md-nav__link> Per-Vertex Data </a> <nav class=md-nav aria-label="Per-Vertex  Data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#step-1-generate-the-buffer class=md-nav__link> Step 1: Generate the Buffer </a> </li> <li class=md-nav__item> <a href=#step-2-bind-the-buffer class=md-nav__link> Step 2: Bind the Buffer </a> </li> <li class=md-nav__item> <a href=#step-3-buffer-the-data class=md-nav__link> Step 3: Buffer the Data </a> </li> <li class=md-nav__item> <a href=#step-4-configure-set-vertex-attribute-pointers class=md-nav__link> Step 4: Configure - Set Vertex Attribute Pointers </a> </li> <li class=md-nav__item> <a href=#step-5-draw class=md-nav__link> Step 5: Draw! </a> </li> <li class=md-nav__item> <a href=#step-6-cleanup class=md-nav__link> Step 6: Cleanup </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#global-data class=md-nav__link> Global Data </a> <nav class=md-nav aria-label="Global Data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#step-1-declare-the-uniform-in-the-shader-glsl class=md-nav__link> Step 1: Declare the Uniform in the Shader (GLSL) </a> </li> <li class=md-nav__item> <a href=#step-2-get-the-uniforms-location class=md-nav__link> Step 2: Get the Uniform's "Location" </a> </li> <li class=md-nav__item> <a href=#step-3-set-the-uniforms-value class=md-nav__link> Step 3: Set the Uniform's Value </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#compare-vbos-and-uniforms class=md-nav__link> Compare VBOs and Uniforms </a> </li> <li class=md-nav__item> <a href=#texture-data class=md-nav__link> Texture Data </a> <nav class=md-nav aria-label="Texture Data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1-what-is-a-texture-in-opengl class=md-nav__link> 1. What is a Texture in OpenGL? </a> </li> <li class=md-nav__item> <a href=#2-the-workflow-a-step-by-step-guide class=md-nav__link> 2. The Workflow: A Step-by-Step Guide </a> <nav class=md-nav aria-label="2. The Workflow: A Step-by-Step Guide"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#step-0-load-the-image-from-a-file-cpu-side class=md-nav__link> Step 0: Load the Image from a File (CPU-Side) </a> </li> <li class=md-nav__item> <a href=#step-1-generate-a-texture-object class=md-nav__link> Step 1: Generate a Texture Object </a> </li> <li class=md-nav__item> <a href=#step-2-bind-the-texture class=md-nav__link> Step 2: Bind the Texture </a> </li> <li class=md-nav__item> <a href=#step-3-set-texture-parameters-wrapping-and-filtering class=md-nav__link> Step 3: Set Texture Parameters (Wrapping and Filtering) </a> </li> <li class=md-nav__item> <a href=#step-4-upload-the-texture-data-to-the-gpu class=md-nav__link> Step 4: Upload the Texture Data to the GPU </a> </li> <li class=md-nav__item> <a href=#step-5-generate-mipmaps-optional-but-recommended class=md-nav__link> Step 5: Generate Mipmaps (Optional but Recommended) </a> </li> <li class=md-nav__item> <a href=#step-6-free-the-image-data-from-cpu-memory class=md-nav__link> Step 6: Free the Image Data from CPU Memory </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3-how-to-use-the-texture-in-shaders class=md-nav__link> 3. How to Use the Texture in Shaders </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> references </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../Matrices%20in%20opengl/ class=md-nav__link> Matrices in opengl </a> </li> <li class=md-nav__item> <a href="../VBO/ Indexing.md" class=md-nav__link> VBO Indexing </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5> network <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=network data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> network </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../network/tcp/ class=md-nav__link> TCP </a> </li> <li class=md-nav__item> <a href=../../../network/icmp/ class=md-nav__link> ICMP </a> </li> <li class=md-nav__item> <a href=../../../network/dns/ class=md-nav__link> DNS </a> </li> <li class=md-nav__item> <a href=../../../network/dhcp/ class=md-nav__link> DHCP </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_6 type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6> database <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=database data-md-level=1> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> database </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../database/sql/ class=md-nav__link> SQL </a> </li> <li class=md-nav__item> <a href=../../../database/B%2B%20Tree/B%2B%20Tree/ class=md-nav__link> B+ Tree </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#shaders class=md-nav__link> Shaders </a> </li> <li class=md-nav__item> <a href=#per-vertex-data class=md-nav__link> Per-Vertex Data </a> <nav class=md-nav aria-label="Per-Vertex  Data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#step-1-generate-the-buffer class=md-nav__link> Step 1: Generate the Buffer </a> </li> <li class=md-nav__item> <a href=#step-2-bind-the-buffer class=md-nav__link> Step 2: Bind the Buffer </a> </li> <li class=md-nav__item> <a href=#step-3-buffer-the-data class=md-nav__link> Step 3: Buffer the Data </a> </li> <li class=md-nav__item> <a href=#step-4-configure-set-vertex-attribute-pointers class=md-nav__link> Step 4: Configure - Set Vertex Attribute Pointers </a> </li> <li class=md-nav__item> <a href=#step-5-draw class=md-nav__link> Step 5: Draw! </a> </li> <li class=md-nav__item> <a href=#step-6-cleanup class=md-nav__link> Step 6: Cleanup </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#global-data class=md-nav__link> Global Data </a> <nav class=md-nav aria-label="Global Data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#step-1-declare-the-uniform-in-the-shader-glsl class=md-nav__link> Step 1: Declare the Uniform in the Shader (GLSL) </a> </li> <li class=md-nav__item> <a href=#step-2-get-the-uniforms-location class=md-nav__link> Step 2: Get the Uniform's "Location" </a> </li> <li class=md-nav__item> <a href=#step-3-set-the-uniforms-value class=md-nav__link> Step 3: Set the Uniform's Value </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#compare-vbos-and-uniforms class=md-nav__link> Compare VBOs and Uniforms </a> </li> <li class=md-nav__item> <a href=#texture-data class=md-nav__link> Texture Data </a> <nav class=md-nav aria-label="Texture Data"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1-what-is-a-texture-in-opengl class=md-nav__link> 1. What is a Texture in OpenGL? </a> </li> <li class=md-nav__item> <a href=#2-the-workflow-a-step-by-step-guide class=md-nav__link> 2. The Workflow: A Step-by-Step Guide </a> <nav class=md-nav aria-label="2. The Workflow: A Step-by-Step Guide"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#step-0-load-the-image-from-a-file-cpu-side class=md-nav__link> Step 0: Load the Image from a File (CPU-Side) </a> </li> <li class=md-nav__item> <a href=#step-1-generate-a-texture-object class=md-nav__link> Step 1: Generate a Texture Object </a> </li> <li class=md-nav__item> <a href=#step-2-bind-the-texture class=md-nav__link> Step 2: Bind the Texture </a> </li> <li class=md-nav__item> <a href=#step-3-set-texture-parameters-wrapping-and-filtering class=md-nav__link> Step 3: Set Texture Parameters (Wrapping and Filtering) </a> </li> <li class=md-nav__item> <a href=#step-4-upload-the-texture-data-to-the-gpu class=md-nav__link> Step 4: Upload the Texture Data to the GPU </a> </li> <li class=md-nav__item> <a href=#step-5-generate-mipmaps-optional-but-recommended class=md-nav__link> Step 5: Generate Mipmaps (Optional but Recommended) </a> </li> <li class=md-nav__item> <a href=#step-6-free-the-image-data-from-cpu-memory class=md-nav__link> Step 6: Free the Image Data from CPU Memory </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3-how-to-use-the-texture-in-shaders class=md-nav__link> 3. How to Use the Texture in Shaders </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> references </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>Data shared between CPU and GPU</h1> <h2 id=shaders>Shaders</h2> <p>In the simplest possible configuration, you will need two shaders : one called Vertex Shader, which will be executed for each vertex, and one called Fragment Shader, which will be executed for each sample. If we use 4x antialising, we have 4 samples in each pixel.</p> <p>Shaders are programmed in a language called GLSL : GL Shader Language, which is part of OpenGL. Unlike C or Java, GLSL has to be compiled at run time, which means that each and every time you launch your application, all your shaders are recompiled. Shaders code run in GPU, so we need some way to share data between CPU and GPU.</p> <h2 id=per-vertex-data>Per-Vertex Data</h2> <p>Per-Vertex Data in OpenGl is stored in a buffer called Vertex Buffer Object (VBO). VBO is used to send the attributes (Vertex positions, Vertex colors, Texture coordinate, Normal vectors) of vertices to Vertex Shader, one item of buffer bind one vertex. The OpenGL buffer is created, bound, filled and configured with the standard functions (<code>glGenBuffers</code>, <code>glBindBuffer</code>, <code>glBufferData</code>, <code>glVertexAttribPointer</code>) ;</p> <h4 id=step-1-generate-the-buffer>Step 1: Generate the Buffer</h4> <p>First, you ask OpenGL to create a buffer object for you. It returns a unique ID (an unsigned integer) that you use to refer to that buffer.</p> <pre><code class=language-c++>GLuint VBO_ID; 
glGenBuffers(1, &amp;VBO_ID); // Generate 1 buffer and store its ID in VBO_ID
</code></pre> <h4 id=step-2-bind-the-buffer>Step 2: Bind the Buffer</h4> <p>OpenGL is a state machine. To work with a specific buffer, you must first "bind" it, making it the currently active buffer for a specific target. For vertex data, the target isGL_ARRAY_BUFFER.</p> <pre><code class=language-c++>// Make our new buffer the active GL_ARRAY_BUFFER 
glBindBuffer(GL_ARRAY_BUFFER, VBO_ID);
</code></pre> <p>AnyGL_ARRAY_BUFFERoperations will now affectVBO_ID.</p> <h4 id=step-3-buffer-the-data>Step 3: Buffer the Data</h4> <p>This is the crucial step where you copy your vertex data from your application's memory (on the CPU) to the buffer's memory (on the GPU).</p> <pre><code class=language-c++>// Our vertex data in an array on the CPU
float vertices[] = {
    // positions         // colors
    -0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f, // bottom left
     0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f, // bottom right
     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f  // top center
};

// Copy the data into the currently bound buffer (VBO_ID)
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
</code></pre> <p>Let's break down <code>glBufferData</code>:</p> <ul> <li>target:GL_ARRAY_BUFFER, the buffer type we're working with.</li> <li>size: The total size of the data in bytes (sizeof(vertices)).</li> <li>data: A pointer to the actual vertex data (vertices).</li> <li>usage: A hint to OpenGL about how we'll use this data.<ul> <li>GL_STATIC_DRAW: The data will be set once and used many times (e.g., a static model) </li> <li>GL_DYNAMIC_DRAW: The data will be changed frequently and used many times (e.g., a character's animation).</li> <li>GL_STREAM_DRAW: The data will be set once and used only a few times.</li> </ul> </li> </ul> <h4 id=step-4-configure-set-vertex-attribute-pointers>Step 4: Configure - Set Vertex Attribute Pointers</h4> <p>The GPU now has your data, but it doesn't know how to interpret it. Is it just a big blob of floats? You need to tell it: "Okay, the first 3 floats of each vertex are its position. The next 3 floats are its color."</p> <p>This is done with <code>glVertexAttribPointer</code>.</p> <pre><code class=language-c++>// Tell OpenGL how to interpret the position data (attribute 0)
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0); // Enable attribute 0


// Tell OpenGL how to interpret the color data (attribute 1)
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1); // Enable attribute 1

</code></pre> <p>Let's break down <code>glVertexAttribPointer</code>:</p> <ul> <li>index: The vertex attribute's location. In shaders, you'd have<code>layout (location = 0) in vec3 aPos;</code>. This<code>0</code>matches the index.</li> <li>size: The number of components per vertex attribute (e.g., 3 for a vec3 position).</li> <li>type: The data type of the components (GL_FLOAT).</li> <li>normalized: Whether the data should be normalized (we don't need this for floats).</li> <li>stride: The byte-offset between consecutive vertices. Our vertex has 6 floats (3 pos + 3 color), so the stride is<code>6 * sizeof(float)</code>.</li> <li>pointer(offset): The offset of the first component of this attribute in the vertex. For position, it's 0. For color, it starts after the 3 position floats, so its offset is<code>3 * sizeof(float)</code>.</li> </ul> <p>Corresponding code in Vertex Shader</p> <pre><code class=language-Glsl>// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexColor;
</code></pre> <h4 id=step-5-draw>Step 5: Draw!</h4> <p>Now, in your render loop, you just need to bind the VBO and tell OpenGL to draw.</p> <pre><code class=language-c++>// In the render loop
glBindBuffer(GL_ARRAY_BUFFER, VBO_ID);
glDrawArrays(GL_TRIANGLES, 0, 3); // Draw 3 vertices, starting from index 0
</code></pre> <p><strong>Improvement with VAOs:</strong> The process in Step 4 and 5 is often simplified by a <strong>Vertex Array Object (VAO)</strong>, which "remembers" all the <code>glVertexAttribPointer</code> calls and VBO bindings for you. In modern OpenGL, you'd set up a VAO once, and in the render loop, you would just bind the VAO and call <code>glDrawArrays</code>.</p> <h4 id=step-6-cleanup>Step 6: Cleanup</h4> <p>When you're done with the buffer (e.g., closing the application), you should delete it to free up GPU memory.</p> <pre><code class=language-c++>glDeleteBuffers(1, &amp;VBO_ID);
</code></pre> <h2 id=global-data>Global Data</h2> <p>Global Data in OpenGl called Uniform. Uniform can be used to send global data to all shaders. Its key characteristic is that its value is <strong>uniform</strong> (constant and unchanging) for every single vertex and fragment processed within a single draw call.</p> <h4 id=step-1-declare-the-uniform-in-the-shader-glsl>Step 1: Declare the Uniform in the Shader (GLSL)</h4> <p>ou declare it in your shader code just like a global variable, using the uniform keyword.</p> <pre><code class=language-GLSL>uniform vec3 LightPosition_worldspace;
</code></pre> <h4 id=step-2-get-the-uniforms-location>Step 2: Get the Uniform's "Location"</h4> <p>In your CPU-side code, after you've compiled and linked your shader program, you need to ask OpenGL for the "location" of your uniform. This is just an integer ID that OpenGL uses to refer to that specific uniform.</p> <p>You only need to do this<strong>once</strong>after creating the shader program.</p> <pre><code class=language-c++>GLuint LightID = glGetUniformLocation(programID, &quot;LightPosition_worldspace&quot;);
// It's good practice to check if the uniform was found. // It might not be found if it's unused in the shader, as the compiler may optimize it out. 
if (LightID == -1) { 
    // Handle error... 
}

</code></pre> <h4 id=step-3-set-the-uniforms-value>Step 3: Set the Uniform's Value</h4> <p>This is done in your<strong>render loop</strong>, right before you make a draw call (glDrawArraysorglDrawElements).</p> <p><strong>Crucially, you mustglUseProgramfirst</strong>to make your shader active, as theglUniformfunctions operate on the currently active program.</p> <pre><code class=language-c++>// In the render loop...
glm::vec3 lightPos = glm::vec3(4, 4, 4);
glUniform3f(LightID, lightPos.x, lightPos.y, lightPos.z);
</code></pre> <h2 id=compare-vbos-and-uniforms>Compare VBOs and Uniforms</h2> <ul> <li> <p><strong>VBOs</strong> hold data that is <strong>different for each vertex</strong> (like positions). They are loaded once into GPU memory.</p> </li> <li> <p><strong>Uniforms</strong> hold data that is the <strong>same for all vertices</strong> in a draw call (like a transformation matrix or global color). They are set from the CPU just before drawing.</p> </li> </ul> <p>Together, VBOs and Uniforms form the fundamental way you communicate all necessary rendering data to the GPU in modern OpenGL.</p> <table> <thead> <tr> <th>Feature</th> <th>Vertex Attribute (from VBO)</th> <th>Uniform</th> </tr> </thead> <tbody> <tr> <td><strong>Scope</strong></td> <td>Per-Vertex</td> <td>Per-Draw Call (Global to the shader program)</td> </tr> <tr> <td><strong>Data Source</strong></td> <td>Read from a Vertex Buffer Object (VBO)</td> <td>Set directly from CPU application code before drawing.</td> </tr> <tr> <td><strong>Variability</strong></td> <td>Value is <strong>different</strong> for each vertex.</td> <td>Value is the <strong>same</strong> for all vertices and fragments.</td> </tr> <tr> <td><strong>Typical Use</strong></td> <td>Position, per-vertex color, normals, texture coordinates.</td> <td>Transformation matrices, time, lighting properties, global color.</td> </tr> </tbody> </table> <h2 id=texture-data>Texture Data</h2> <p>Texture data is stored in buffer, but unlike vertex data, it is global data rather than per-vertex data, so Texture Data is a form of global buffer data. Sending texture data is the third pillar of getting data to the GPU, alongside VBOs (per-vertex data) and Uniforms (global data).</p> <h3 id=1-what-is-a-texture-in-opengl>1. What is a Texture in OpenGL?</h3> <p>In OpenGL, a <strong>Texture</strong> is a memory object, typically living on the GPU, that stores image data. This data can be 1D, 2D, or 3D, but the most common form is a 2D texture used to wrap an image around a 3D model.</p> <p>The process involves:</p> <ol> <li>Loading an image file (like a .png or .jpg) into your application's memory (CPU).</li> <li>Creating an OpenGL texture object.</li> <li>Uploading the pixel data from your application to the texture object on the GPU.</li> <li>Telling the shader how to use this texture.</li> </ol> <h3 id=2-the-workflow-a-step-by-step-guide>2. The Workflow: A Step-by-Step Guide</h3> <p>Here is the complete process for loading and using a texture.</p> <h4 id=step-0-load-the-image-from-a-file-cpu-side>Step 0: Load the Image from a File (CPU-Side)</h4> <p>OpenGL itself does <strong>not</strong> know how to open and read image files. You must use a third-party library for this. The most popular and easiest one for beginners is <strong>stb_image.h</strong>.</p> <p>You include this library and it gives you a simple function to load an image into a byte array.</p> <pre><code class=language-c++>#include &quot;stb_image.h&quot; // A popular single-header image loading library

int width, height, nrChannels;
unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);

if (data) {
    // Image loaded successfully!
    // 'width' and 'height' have the image dimensions.
    // 'nrChannels' is 3 for RGB, 4 for RGBA.
    // 'data' is a pointer to the raw pixel data.
} else {
    // Failed to load image
}
</code></pre> <h4 id=step-1-generate-a-texture-object>Step 1: Generate a Texture Object</h4> <p>Just like with VBOs, you ask OpenGL to generate a unique ID for your texture.</p> <pre><code class=language-c++>GLuint textureID;
glGenTextures(1, &amp;textureID);
</code></pre> <h4 id=step-2-bind-the-texture>Step 2: Bind the Texture</h4> <p>You bind the texture to make it the active one for a specific target. For standard images, the target is GL_TEXTURE_2D.</p> <pre><code>glBindTexture(GL_TEXTURE_2D, textureID);
</code></pre> <p>All subsequent texture commands for GL_TEXTURE_2D will now configure the texture with ID textureID.</p> <h4 id=step-3-set-texture-parameters-wrapping-and-filtering>Step 3: Set Texture Parameters (Wrapping and Filtering)</h4> <p>Before you upload the data, you should tell OpenGL how to handle the texture when it's rendered.</p> <ul> <li><strong>Wrapping:</strong> What happens if the texture coordinates are outside the [0, 1] range?<ul> <li>GL_REPEAT: The texture repeats.</li> <li>GL_CLAMP_TO_EDGE: The edge color is stretched.</li> </ul> </li> <li><strong>Filtering:</strong> What happens when the texture is scaled up (magnified) or down (minified)?<ul> <li>GL_NEAREST: "Pixelated" look. Fast but blocky.</li> <li>GL_LINEAR: "Blurry" look. Smooth but can be blurry up close.</li> </ul> </li> </ul> <pre><code class=language-c++>// Set texture wrapping parameters
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); // S is for the x-axis (like U)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // T is for the y-axis (like V)

// Set texture filtering parameters
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); // Minification (zoomed out)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Magnification (zoomed in)
</code></pre> <h4 id=step-4-upload-the-texture-data-to-the-gpu>Step 4: Upload the Texture Data to the GPU</h4> <p>This is the core step where you send the pixel data from Step 0 to the currently bound texture object on the GPU. The function for this is glTexImage2D.</p> <pre><code class=language-c++>// Using the variables from stb_image.h
// Note: We check nrChannels to determine the format
GLenum format = (nrChannels == 4) ? GL_RGBA : GL_RGB;

glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
</code></pre> <p>Let's break down the glTexImage2D parameters:</p> <ul> <li>target: GL_TEXTURE_2D.</li> <li>level: Mipmap level. 0 is the base level.</li> <li>internalFormat: The format OpenGL should use to store the texture (e.g., GL_RGB).</li> <li>width, height: Dimensions of the image from Step 0.</li> <li>border: Legacy, should always be 0.</li> <li>format: The format of the source data you are providing (GL_RGB or GL_RGBA).</li> <li>type: The data type of the source data (GL_UNSIGNED_BYTE for standard images).</li> <li>data: The pointer to the image data we loaded with stb_image.</li> </ul> <h4 id=step-5-generate-mipmaps-optional-but-recommended>Step 5: Generate Mipmaps (Optional but Recommended)</h4> <p>Mipmaps are pre-calculated, smaller versions of your texture that OpenGL will automatically use when the object is far away. This prevents visual artifacts (moiré patterns) and improves performance.</p> <pre><code class=language-c++>glGenerateMipmap(GL_TEXTURE_2D);
</code></pre> <p>This automatically generates all the smaller mipmap levels from the base image you just uploaded. For this to work best, you should set your GL_TEXTURE_MIN_FILTER to one of the mipmap options, like GL_LINEAR_MIPMAP_LINEAR.</p> <h4 id=step-6-free-the-image-data-from-cpu-memory>Step 6: Free the Image Data from CPU Memory</h4> <p>Once the data is on the GPU, you no longer need the copy in your application's memory.</p> <pre><code class=language-c++>stbi_image_free(data);
</code></pre> <p>full code :</p> <pre><code class=language-c++>#include &quot;stb_image.h&quot; // Don't forget to include this

// A helper function to load a texture from a file
unsigned int loadTexture(const char* path) {
    unsigned int textureID;
    glGenTextures(1, &amp;textureID);

    int width, height, nrChannels;
    // Tell stb_image.h to flip loaded textures on the y-axis (common in OpenGL)
    stbi_set_flip_vertically_on_load(true);
    unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrChannels, 0);

    if (data) {
        GLenum format;
        if (nrChannels == 1) format = GL_RED;
        else if (nrChannels == 3) format = GL_RGB;
        else if (nrChannels == 4) format = GL_RGBA;

        glBindTexture(GL_TEXTURE_2D, textureID);
        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
        glGenerateMipmap(GL_TEXTURE_2D);

        // Set texture wrapping and filtering options
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    } else {
        std::cout &lt;&lt; &quot;Failed to load texture: &quot; &lt;&lt; path &lt;&lt; std::endl;
    }

    stbi_image_free(data); // Free the CPU-side image memory
    return textureID;
}
</code></pre> <h3 id=3-how-to-use-the-texture-in-shaders>3. How to Use the Texture in Shaders</h3> <p>Now that the texture is on the GPU, you need to tell your shader how to access it. This involves <strong>Texture Units</strong> and a special uniform type called a <strong>Sampler</strong>.</p> <p>A GPU has a limited number of "texture slots" or <strong>Texture Units</strong> (e.g., 16 or 32). You need to:</p> <ol> <li>Activate a texture unit.</li> <li>Bind your texture to that unit.</li> <li>Tell the shader which unit to look at.</li> </ol> <p><strong>In the Shader (GLSL):</strong><br> You need two things:</p> <ol> <li>The texture coordinates from the vertex shader.</li> <li>A sampler2D uniform in the fragment shader.</li> </ol> <p><strong>Vertex Shader:</strong></p> <pre><code class=language-glsl>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord; // Comes from a VBO

out vec2 TexCoord; // Pass texture coords to the fragment shader

void main()
{
    gl_Position = vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
</code></pre> <p><strong>Fragment Shader:</strong></p> <pre><code class=language-glsl>#version 330 core
out vec4 FragColor;

in vec2 TexCoord; // Received from the vertex shader

// The texture sampler uniform.
// This will get its data from a specific texture unit.
uniform sampler2D ourTexture;

void main()
{
    // The texture() function looks up the color from the texture
    // at the given texture coordinates.
    FragColor = texture(ourTexture, TexCoord);
}
</code></pre> <p><strong>In your Render Loop (C++):</strong><br> Before you draw, you must bind the texture to a texture unit and tell the sampler uniform which unit to use.</p> <pre><code class=language-c++>// In the render loop...

glUseProgram(shaderProgramID);

// 1. Activate texture unit 0
glActiveTexture(GL_TEXTURE0);

// 2. Bind your texture to the active unit
glBindTexture(GL_TEXTURE_2D, textureID);

// 3. Tell the 'ourTexture' sampler to use texture unit 0
// glGetUniformLocation is used to get the location of &quot;ourTexture&quot;
glUniform1i(glGetUniformLocation(shaderProgramID, &quot;ourTexture&quot;), 0);

// 4. Draw your object
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
</code></pre> <p>The magic is in the <code>glUniform1i(..., 0)</code> call. You are setting the integer value of the sampler2D uniform to 0, which corresponds to <code>GL_TEXTURE0</code>, the unit you just bound your texture to. If you were using a second texture, you would bind it to <code>GL_TEXTURE1</code> and set its corresponding sampler uniform to 1.</p> <h2 id=references>references</h2> <p>https://www.opengl-tutorial.org/beginners-tutorials/tutorial-2-the-first-triangle/</p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../../../math/distance%20from%20point%20to%20plane/ class="md-footer__link md-footer__link--prev" aria-label="Previous: distance from point  to plane" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Previous </span> distance from point to plane </div> </div> </a> <a href=../Matrices%20in%20opengl/ class="md-footer__link md-footer__link--next" aria-label="Next: Matrices in opengl" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Next </span> Matrices in opengl </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script> <script src=../../../assets/javascripts/bundle.6c7ad80a.min.js></script> </body> </html>