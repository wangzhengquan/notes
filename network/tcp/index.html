<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://wangzhengquan.github.io/notes/network/tcp/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.3.1, mkdocs-material-8.3.9"><title>TCP - 笔记</title><link rel=stylesheet href=../../assets/stylesheets/main.1d29e8d0.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.cbb835fc.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme data-md-color-primary=none data-md-color-accent=none> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#transmission-control-protocol-tcp class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title=笔记 class="md-header__button md-logo" aria-label=笔记 data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> 笔记 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> TCP </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title=笔记 class="md-nav__button md-logo" aria-label=笔记 data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> 笔记 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> 简介 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> OS (xv6) <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="OS (xv6)" data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> OS (xv6) </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../xv6/ class=md-nav__link> xv6简介 </a> </li> <li class=md-nav__item> <a href=../../xv6/boot_loader/ class=md-nav__link> Boot loader </a> </li> <li class=md-nav__item> <a href=../../xv6/entry_%20kernel/ class=md-nav__link> Entry kernel </a> </li> <li class=md-nav__item> <a href=../../xv6/scheduler/ class=md-nav__link> Scheduler </a> </li> <li class=md-nav__item> <a href=../../xv6/the_first_process/ class=md-nav__link> 第一个进程 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_6 type=checkbox id=__nav_2_6> <label class=md-nav__link for=__nav_2_6> 中断 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=中断 data-md-level=2> <label class=md-nav__title for=__nav_2_6> <span class="md-nav__icon md-icon"></span> 中断 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../xv6/interrups_process/ class=md-nav__link> 中断处理流程 </a> </li> <li class=md-nav__item> <a href=../../xv6/system_call/ class=md-nav__link> 系统调用 </a> </li> <li class=md-nav__item> <a href=../../xv6/timer_interrupt/ class=md-nav__link> 时间中断 </a> </li> <li class=md-nav__item> <a href=../../xv6/disk_interrupt/ class=md-nav__link> 硬盘中断 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../xv6/file_system/ class=md-nav__link> 文件系统 </a> </li> <li class=md-nav__item> <a href=../../xv6/device/ class=md-nav__link> 设备管理 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3 checked> <label class=md-nav__link for=__nav_3> network <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=network data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> network </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> TCP <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> TCP </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#sliding-window class=md-nav__link> 滑动窗口（Sliding window） </a> </li> <li class=md-nav__item> <a href=#reliable-data-transfer class=md-nav__link> 可靠传输（Reliable data transfer） </a> </li> <li class=md-nav__item> <a href=#flow-control class=md-nav__link> 流控制 （Flow Control） </a> </li> <li class=md-nav__item> <a href=#congestion-control class=md-nav__link> 拥堵控制 （Congestion Control） </a> </li> <li class=md-nav__item> <a href=#tcp-connection-managementconnectionconnection class=md-nav__link> TCP Connection Management———Connection建立，Connection关闭，状态转换 </a> </li> <li class=md-nav__item> <a href=#1-simultaneous-open class=md-nav__link> 1. Simultaneous Open </a> </li> <li class=md-nav__item> <a href=#2-simultaneous-close class=md-nav__link> 2. Simultaneous Close </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../icmp/ class=md-nav__link> ICMP </a> </li> <li class=md-nav__item> <a href=../dns/ class=md-nav__link> DNS </a> </li> <li class=md-nav__item> <a href=../dhcp/ class=md-nav__link> DHCP </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4> database <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=database data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> database </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../database/sql/ class=md-nav__link> SQL </a> </li> <li class=md-nav__item> <a href=../../database/B%2B%20Tree/B%2B%20Tree/ class=md-nav__link> B+ Tree </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#sliding-window class=md-nav__link> 滑动窗口（Sliding window） </a> </li> <li class=md-nav__item> <a href=#reliable-data-transfer class=md-nav__link> 可靠传输（Reliable data transfer） </a> </li> <li class=md-nav__item> <a href=#flow-control class=md-nav__link> 流控制 （Flow Control） </a> </li> <li class=md-nav__item> <a href=#congestion-control class=md-nav__link> 拥堵控制 （Congestion Control） </a> </li> <li class=md-nav__item> <a href=#tcp-connection-managementconnectionconnection class=md-nav__link> TCP Connection Management———Connection建立，Connection关闭，状态转换 </a> </li> <li class=md-nav__item> <a href=#1-simultaneous-open class=md-nav__link> 1. Simultaneous Open </a> </li> <li class=md-nav__item> <a href=#2-simultaneous-close class=md-nav__link> 2. Simultaneous Close </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=transmission-control-protocol-tcp>Transmission Control Protocol (TCP)</h1> <p>TCP是一种可靠传输的协议，而实现可靠和高效的传输需要用到一系列的机制，技巧和算法，下面一一介绍。</p> <h2 id=sliding-window>滑动窗口（Sliding window）</h2> <p>滑动窗口是实现可靠传输和控制发送速率的关键。一个TCP网络端点（endpoint）有两个滑动窗口，一个是负责接收的滑动窗口，一个是负责发送的滑动窗口.</p> <p>接收的滑动窗口如下图所示，first unread到first unassembled这一段序列的数据是已经接收到并组装好准备被读取的数据。first unassembled是接受端期待发送端发送的下一个包的序号，也就是要发送的acknowledge包中ackno的值。 first unassembled 到 first unacceptable 之间就是接受端缓存的剩余容量，也就是receive window 的大小，新来的数据就放到这里进行组装。receive window 是后面要用到的一个变量，表示为rwnd，它的计算公式如下：</p> <pre><code>rwnd= first unacceptable - first unassembled
</code></pre> <p><img alt=tcp src=../img/tcp_receiver_sliding_win.png title="Receiver’s view of sliding window"></p> <p>发送的滑动窗口如下图所示，base到nextseqnum这一段序列是已经发送出去但未收到应答的数据(outstanding bytes)。base是已经收到的acknowledge包中的ackno的最大值, base之前的数据都是已经确认被对方收到了的数据。TCP采用的是累积应答(cumulative acknowledgments),每收到一个应答包就表示ackno之前的所有字节都已经被对方接受成功了。nextseqnum是下一次准备发送的数据包的起始序列号。base和nextseqnum之间的数据是已经发送但是未收到应答的数据( unacknowledged bytes)，也叫outstanding bytes或bytes in flight。outstanding bytes是后面要用到一个变量，它的计算公式如下：</p> <pre><code>outstanding bytes = nextseqnum - base
</code></pre> <p><img alt=tcp src=../img/tcp_sender_sliding_win.png title="Sender’s view of sliding window"></p> <h2 id=reliable-data-transfer>可靠传输（Reliable data transfer）</h2> <p>TCP的可靠传输是靠对丢失的包重传(retransmition)实现的, 而确认一个包是否丢失是靠超时(timeout)与重复应答(duplicate acknowledges)两种机制——duplicate acknowledges就是重复收到原来已经收到过的针对某个包的应答(ACK)。</p> <p>要实现超时机制就要确定超时时间，要确定超时时间就需要知道Round-Trip Time。Round-Trip Time可以通过之前发送的包的RTT进行估算。所以要对之前发送的包的RTT进行采样得到SampleRTT。这里并不是针对每一个发送出的包都要进行采样，而是每完成一个RTT采样紧接着再进行下一次采样，也就是每隔一个RTT的时间段采样一次。估算RTT的公式为</p> <pre><code>EstimatedRTT = (1 – α) * EstimatedRTT +  α * SampleRTT 
</code></pre> <p>除了要估算RTT还有计算RTT的变化性DevRTT。所谓的变化性就是EstimatedRTT与SampleRTT的偏离程度。公式如下：</p> <pre><code>DevRTT = (1 – β) * DevRTT + β * | SampleRTT – EstimatedRTT | 
</code></pre> <p>如果SampleRTT的波动很小那么DevRTT的值就很小，反之就很大。</p> <p>最终超时时间就是EstimatedRTT加上一个波动的margin值，这个margin值就是DevRTT，</p> <pre><code>TimeoutInterval = EstimatedRTT + 4 * DevRTT
</code></pre> <p>TimeoutInterval的初始值是1 second, 每次超时的时候TimeoutInterval的值都要翻倍，但是一旦收到一个新的应答包，TimeoutInterval就又要用上面的公式计算。</p> <p>综上所述，Estimating the Round-Trip Time的实现代码如下</p> <pre><code>TimeoutInterval = 1;

int EstimateTimeout() {
    α=0.125
    β=0.25

    EstimatedRTT = (1 – α) * EstimatedRTT +  α * SampleRTT 
    DevRTT = (1 – β) * DevRTT + β * | SampleRTT – EstimatedRTT | 
    TimeoutInterval = EstimatedRTT + 4 * DevRTT
    return TimeoutInterval;
}

</code></pre> <p>有了超时时间就可以使用计时器了，计时器也不是对每个发出的包都要进行跟踪计时，而是只对最早的(序列号最小的)一个未应答包进行计时。</p> <p>下面的代码是一个发送端的伪代码, 描述了发送包时定时器的启动，超时的处理，重复应答的处理。</p> <pre><code>/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */

NextSeqNum=InitialSeqNumber 
SendBase=InitialSeqNumber
TimeoutInterval=1s

loop (forever) { 
    switch(event)

        event: data received from application above
            create TCP segment with sequence number NextSeqNum 
            if (timer currently not running) {
                start timer
            }
            pass segment to IP
            NextSeqNum=NextSeqNum+length(data) 
            break;

        event: timer timeout
            retransmit not-yet-acknowledged segment with smallest sequence number 
            TimeoutInterval *= 2;
            start timer
            break;

        event: ACK received, with ACK field value of y 
            if (y &gt; SendBase) {
                SendBase=y
                if (there are currently any not yet acknowledged segments) {
                    TimeoutInterval = EstimateTimeout() ; 
                    start timer
                }
            }
            else {
                /* a duplicate ACK for already ACKed segment */
                increment number of duplicate ACKs received for y
                if (number of duplicate ACKS received for y==3)
                    /* TCP fast retransmit */
                    resend segment with sequence number y 
            }
            break;

} /* end of loop forever */
</code></pre> <p>在上面的代码中，每次发送数据如果计时器没有启动就要启动计时器，也就是说计时器追踪的是已经发送且未应答包中的第一个包。每当超时发生时就认为该包已经丢失了所以要进行重传，而且超时时间要设为原来的两倍，并重新计时。当一个已经被应答过的包又收到了3次以上的重复应答也认为该包已经丢失了，所以也要进行重传。</p> <p>接受端的代码如下：</p> <pre><code>loop (forever) { 
    event: Arrival of segment
        if (segment is in-order ) {
            if (Arrival of segment that partially or completely fills in gap in received data.) {
                Immediately send ACK, provided that segment starts at the lower end of gap.

                return;
            }

            if(All data up to expected sequence number already acknowledged.) {
                Delayed ACK. Wait up to 500 msec for arrival of another in-order segment. If next in-order segment does not arrive in this interval, send an ACK.
            } 
            else if (One other in-order segment waiting for ACK transmission.){
                Immediately send single cumulative ACK, ACKing both in-order segments.
            }
        }
        else if(segment is out-of-order) {
            // with higher-than-expected sequence number. Gap detected.
            Immediately send duplicate ACK, indicating sequence number of next expected byte (which is the lower end of the gap).
        }
}

</code></pre> <p>因为TCP的每一个端点既是接受端也是发送端，所以在实际的代码实现中上述接受端和发送端是要整合到一起的。</p> <h2 id=flow-control>流控制 （Flow Control）</h2> <p>为什么需要Flow Control，书里的这段话做了很好解释。If the application is relatively slow at reading the data, the sender can very easily overflow the connection’s receive buffer by sending too much data too quickly. TCP provides a flow-control service to its applications to eliminate the possibility of the sender overflowing the receiver’s buffer. Flow control is thus a speed matching service, matching the rate at which the sender is sending against the rate at which the receiving application is reading. </p> <p>Flow-Control 就是要保证发送端已经发送但未应答的数据量(outstanding bytes)小于接受端空闲缓存(receive window)的大小。即</p> <pre><code>outstanding bytes &lt; receive window
</code></pre> <p>关于outstanding bytes和receive window请参见滑动窗口那一节。</p> <p>在这个方案中有一个小的技术问题。假设有两个端点A和B互相通信，并假设B的buffer已经填满即rwnd = 0，当B把rwnd = 0通知给A后，假设B没有更多的东西要发送给A了。现在考虑会发生什么事情呢？当B清空了buffer的时候，TCP没有发送带有新的rwnd值的segment给A。因为只有当B有数据或回复要发送的时候才会发送新的segment。所以A永远不会知道B已经释放出了新的空闲缓存。端点A就会被堵塞在那里不会发送任何数据！要解决这个问题，TCP协议标准要求端点A在这种情况下要继续发送paylaod data 为一个字节大小的segment给B。这些segments会被接受方B回复，并把新的rwnd通知到发送方A。</p> <h2 id=congestion-control>拥堵控制 （Congestion Control）</h2> <p>Packet retransmission 可以解决包丢失的问题达到可靠传输的目的， 但是这只是解决了问题的症状，而不是问题的原因。发生丢包的原因一般是网络拥堵造成的，所以要解决问题的原因就是解决网络拥堵的问题，也就是要降低发送数据的速率。这就引出了三个问题。第一，TCP如何限制向它向网络连接发送数据的速率？第二，TCP如何感知到自己与目标连接直接由网络拥堵？第三，发送方应该使用什么算法来根据感知到的端到端拥塞来改变其发送速率。</p> <p>首先解决第一个问题。TCP的发送速率就等于<code>outstanding bytes / RTT</code>, 在滑动窗口那一节中我们已经知道<code>outstanding bytes = nextseqnum - base</code>，所以发送速率的公式如下</p> <pre><code>send rate = (nextseqnum - base) / RTT
</code></pre> <p>现在引入一个新的变量congestion window，表示为cwnd。我们通过确保</p> <pre><code>outstanding bytes = nextseqnum - base &lt;= min{cwnd, rwnd}
</code></pre> <p>来约束TCP发送端向网络发送数据的速率。通过调整cwnd的大小，发送端可依相应调整它向网络发送数据的速率。</p> <p>下面解决第二个问题。TCP发送端如何探测到自己到目标直接的这段路径由拥堵现象发生？有两个迹象可以表明发送端到接受端的路径上产生拥堵了，那就是超时和三次重复应答。</p> <p>最后解决第三个问题。拥堵控制算法有三个组成部分或者说是三种模式 (1) slow start, (2) congestion avoidance, and (3) fast recovery。</p> <p><strong> Slow Start </strong></p> <p>当TCP连接刚开始的时候，cwnd被初始化为一个1 MSS（maximum sized segments）的很小的值，因此它的初始发送速率就是 1MSS/ RTT。通常可用的宽带是远远大于 1MSS / RTT的，因此这时候不会发送丢包，发送端妹收到一个发出包的应答cwnd就增加1MSS。当第一个发送的包收到应答后TCP发送端的cwnd增加一个MSS然后发送两个MSS大小的segments。这两个segments也都分别收到了应答，发送方针对每个应答也都为cwnd新增1MSS大小，变成4MSS大小的cwnd，依次类推。这个过程导致每隔 RTT 的时间，cwnd就翻一倍，发送速率也跟着翻一倍。所以在slow start阶段TCP的发送速率是呈指数增长的。</p> <p>但是这个指数增长什么时候结束呢？在Slow Start阶段有三种情况会导致数增长结束。第一是当有一个超时所表明的丢包事件发生时，TCP 发送端把cwnd设置为1MSS并重新开始slow start的过程。在这种情况下它还会把ssthresh（short- hand for “slow start threshold”）变量设置为cwnd/2，即发现拥堵时的congestion window 值的一半。第二种结束的方式是Slow Start直接与ssthresh绑定。由于上次检测到拥塞时 ssthresh 是 cwnd 值的一半，因此当 cwnd 达到或超过 ssthresh 的值时继续加倍可能有点鲁莽。因此，当 cwnd 的值等于 ssthresh 时，慢启动结束，TCP 转换进入 congestion-avoidance模式。 正如我们将看到的，TCP 在 congestion-avoidance模式下会更加谨慎地增加 cwnd。慢启动结束的最后一种方式是检测到三个重复的 ACK，在这种情况下，TCP 执行 fast retransmit 并进入fast recovery状态。</p> <p><strong> Congestion Avoidance </strong></p> <p>在进入congestion-avoidance状态时，cwnd 的值大约是上次遇到拥塞时值的一半。 因此，TCP 不是在每个 RTT 时将 cwnd 的值加倍，而是采用更保守的方法并在每个 RTT 中仅将 cwnd 的值增加一个 MSS。 这可以通过多种方式实现。 一种常见的方法是 TCP 发送方在新acknowledgment到达时将 cwnd 增加 MSS*(MSS/cwnd) 字节。 例如，如果 MSS 为 1,460 字节，cwnd 为 14,600 字节，则在一个 RTT 内发送 10 个segment。 每个到达的 ACK（假设每个段一个 ACK）将拥塞窗口大小增加 1/10 MSS，因此，当收到所有 10 个段的ACK后，拥塞窗口的值将增加一个 MSS。</p> <p>但是，congestion avoidance的线性增长（每个 RTT 1 MSS）何时结束？ 发生超时表明的丢包事件时，TCP 的 congestion-avoidance算法的处理方式与slow start的情况相同：cwnd 的值设置为 1 MSS，并将 ssthresh 的值更新为 cwnd 值的一半。 然而，回想一下，丢包事件也可以由三次重复的 ACK 事件触发。在这种情况下，按照收到的重复 ACK 所指示的，网络继续从发送方向接收方传送一些数据。 因此，TCP 对这种类型的丢包事件的处理方式没有超时所指示的丢包事件那么剧烈：TCP 将 cwnd 的值减半（增加3个 MSS 以作为收到的三次重复 ACK 的考量）并设置 ssthresh 的值为收到三次重复的 ACK 时的 cwnd 值的一半。 然后进入fast recovery状态。</p> <p><strong> Fast Recovery </strong></p> <p>在fast recovery阶段，对于导致 TCP 进入Fast Recovery状态的丢失segment，每收到一个重复的 ACK，cwnd 的值就会增加 1 MSS。最终，当针对丢失的段的 ACK 到达时，TCP 进入congestion-avoidance状态。如果发生超时事件，fast recovery在执行与slow start 和congestion-avoidance相同的操作后转换到slow start状态：cwnd 的值设置为 1 MSS，ssthresh 的值设置为超时事件发生时cwnd值的一半。</p> <p>关于TCP的congestion control的状态转换图如下：</p> <p><img alt="FSM description of TCP congestion control" src=../img/TCP_congestion_control.png></p> <p>给前面Reliable data transfer那一节的发送端的伪代码加入congestion control的逻辑， 如下</p> <pre><code>MSS=500

NextSeqNum=InitialSeqNumber 
SendBase=InitialSeqNumber
cwnd=MSS
DupAckCount=0
ssthresh=64KB
TimeoutInterval=1s

function bytes_in_flight(){
    return NextSeqNum - SendBase;
}

function window(){
    reutrn min(cwnd, rwnd == 0 ？ 1 : cwnd);
}

loop (forever) { 
    switch(event)

        event: data received from application above
            while(stream has more data) {
                create TCP segment with sequence number NextSeqNum 
                segment.payload = stream.read(min(window() - bytes_in_flight(), MAX_PAYLOAD_SIZE);
                if (timer currently not running) {
                    start timer
                }
                pass segment to IP
                NextSeqNum=NextSeqNum+length(segment.payload) 
            }
            break;

        event: timer timeout
            // entry slow-start
          ssthresh=cwnd/2
          cwnd = 1 MSS
          DupAckCount = 0

            retransmit not-yet-acknowledged segment with smallest sequence number 
            TimeoutInterval *= 2;
            start timer
            break;

        event: ACK received, with ACK field value of y 
            if (y &gt; SendBase) {
                SendBase=y
                if(DupAckCount &gt; 3){
                    // fast-recovery transitions to congestion-avoidence
                    cwnd = ssthresh;
                } else {
                    if(cwnd &gt; ssthresh){
                        // in congetion avoidence
                        cwnd += MSS*(MSS/cwnd) 
                    } else {
                        // in slow start
                        cwnd += MSS
                    }
                }
                DupAckCount = 0
                if (there are currently any not yet acknowledged segments) {
                    TimeoutInterval = EstimateTimeout() ; 
                    start timer
                }
            }
            else {
                /* a duplicate ACK for already ACKed segment */
                DupAckCount++;
                if (DupAckCount==3){
                    // entry fast-recovery
                    ssthresh = cwnd/2
                    cwnd = ssthresh + 3 MSS
                    /* TCP fast retransmit */
                    resend segment with sequence number y 
                } else if (DupAckCount &gt; 3) {
                    // in fast-recovery
                    cwnd += MSS

                }

            }
            break;

} /* end of loop forever */
</code></pre> <h2 id=tcp-connection-managementconnectionconnection>TCP Connection Management———Connection建立，Connection关闭，状态转换</h2> <p>关于TCP的建立连接的三路握手(three-way handshake)和关闭连接的四路挥手是老黄历了，直接上示意图就能明白了,如果一个不够就多上几个</p> <p><a href=http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm>The TCP Finite State Machine</a>示意图如下 <img alt="The TCP Finite State Machine" src=../img/tcp_fsm.png></p> <p>TCP connection的建立和关闭的示意图如下 <img alt=tcp_handshake_and_wave src=../img/tcp_handshake_and_wave.jpg> <img alt src=../img/tcp_handshake.webp> <img alt src=../img/tcp_wave.webp> 另外这篇<a href=https://www.51cto.com/article/619189.html>博文</a>对TCP连接的11种状态做了很好的分析。</p> <p>值得一提的是那个TIME_WAIT状态，TCP主动关闭的一端要在这个状态保持2倍的MSL（最大段生存期）才会结束。之所以这样做有两个原因，一是当被动关闭的一端也发送FIN给主动关闭的一端的时候，如果主动端收到了会回复一个ACK, 但是主动端无法获知被动端是否收到了这个ACK，因为没有针对ACK的ACK。假若被动端没有收到ACK，就会重复发送FIN，所以主动端要等待一端时间如果没有收到重复的FIN就确认对方确实收到了针对FIN的ACK了，反之如果收到了重复的FIN就继续回复ACK。二是，假设在主机12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。此连接关闭后，在相同的地址和端口建立了另外一个连接。由于IP地址和端口相同，所以后一种连接被称为先前连接的“化身”。TCP必须防止连接中的旧副本在稍后再次出现，并被误解为属于同一连接的新“化身”。为此，TCP将不会启动当前处于TIME_WAIT状态的连接的新“化身”。由于一个已经发送的数据包会在MSL的时间后过期，因此 2 MSL保证了一个Round-Trip（发送与回复）的数据都会过期。通过强制执行此规则，可以保证当一个TCP连接成功建立时，来自先前连接的所有旧的副本在网络中已过期。</p> <p>还有一些特殊但是不常见的情况，比如两端同时发送SYN建立连接，或同时发送FIN关闭连接，这里有一篇<a href=https://ttcplinux.sourceforge.net/documents/one/tcpstate/tcpstate.html>博文</a>对者两种情况做了很好的分析，我直接搬过来了。</p> <h2 id=1-simultaneous-open>1. Simultaneous Open</h2> <p>It's possible for two applications to send a SYN to each other to start a TCP connection, although the possibility is small, because both sides have to know which port on the other side to send to. This process is called "Simultaneous Open", or "simultaneous active open on both sides".</p> <p>For example: An application at host A uses 7777 as the local port and connects to port 8888 on host B. At the same time, an application at host B uses 8888 as the local port and connects to port 7777 on host A. This is "Simultaneous Open".</p> <p>TCP is specially designed to deal with "Simultaneous Open", during which only one TCP connection is established, not two. The state transitions are shown in the following figure:</p> <p><img alt="state transition in simultaneous open" src=../img/tcp_simopen.jpg></p> <p>During "Simultaneous Open", 4 packets are exchanged, 1 packet more than in normal situations.</p> <h2 id=2-simultaneous-close>2. Simultaneous Close</h2> <p>It's permitted in TCP for both sides to do "active close", which is called "Simultaneous Close". The state transitions are shown in the following figure:</p> <p><img alt="state transition in simultaneous close" src=../img/tcp_simclose.jpg></p> <p>During "Simultaneous Close", 4 packets are exchanged, the same as in normal situations.</p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../../xv6/device/ class="md-footer__link md-footer__link--prev" aria-label="Previous: 设备管理" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Previous </span> 设备管理 </div> </div> </a> <a href=../icmp/ class="md-footer__link md-footer__link--next" aria-label="Next: ICMP" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Next </span> ICMP </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script> <script src=../../assets/javascripts/bundle.6c7ad80a.min.js></script> </body> </html>